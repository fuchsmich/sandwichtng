--[[
beam system for shear analogy method
(c) 2012 Michael Fuchs michfu@gmx.at

@TODO:
* status des systems speicher: berechnet oder nicht? (zB nach ändern eines Parameters)
* setter/getter für werte?
* struct = nil (freigeben)
* G, kser only for certain sections

@DID:
* y => z für SA
* hb, moe, mos, rho in ein array
* fugensteifigkeit für fugen (k_ser?)
--]]

dofile("crosssection.tng")

function createNodes()
  local dx = SA_l/SA_noe
  local dy = SA_l/5
  local nodes_a = tmath.Matrix(noe+1, 4)
  local nodes_b = tmath.Matrix(noe+1, 4)
  
  for i = 0, noe do
    nodes_a[i] = tmath.Matrix({{1000 + i, i*dx, 0, 0}})
    nodes_b[i] = tmath.Matrix({{2000 + i, i*dx, -dy, 0}})
  end
  
  return nodes_a:AppendRows(nodes_b)
end

function createElements()
  local el_a = tmath.Matrix(SA_noe, 4)
  local el_b = tmath.Matrix(SA_noe, 4)
  
  for i = 0, noe-1 do
    el_a[i] = tmath.Matrix({{1000 + i, 1000 + i, 1001 + i, SA_refnnr}})
    el_b[i] = tmath.Matrix({{2000 + i, 2000 + i, 2001 + i, refnnr}})
  end
  
  return el_a, el_b
end

function createConstraints()
-- same deflection for Beam A and B
  local c = tmath.Matrix(SA_noe-1, 7)
  for i = 1, SA_noe-1 do
    c[i-1] = tmath.Matrix({{2, 1000+i, 1, -1, 2000+i, 1, 1}})
  end
  return c
end

function setSupports()
--   fix reference node
  SA_struct:GetNode(1):SetAvailDof(tmath.Matrix({{0, 0, 0, 0, 0, 0}}))
--   define supports
  SA_struct:GetNode(1000):SetAvailDof(tmath.Matrix({{0, 0, 0, 0, 0, 1}}))
  SA_struct:GetNode(2000):SetAvailDof(tmath.Matrix({{0, 0, 0, 0, 0, 1}}))
  SA_struct:GetNode(1000+noe):SetAvailDof(tmath.Matrix({{1, 0, 0, 0, 0, 1}}))
  SA_struct:GetNode(2000+noe):SetAvailDof(tmath.Matrix({{1, 0, 0, 0, 0, 1}}))
end


-- ============== init the structure
function SA_init(l, noe)
	if l ~= nil then SA_l = l
		else SA_l = 7.2 
	end
	if noe ~= nil then SA_noe = noe
		else SA_noe = 30
	end
	
	SA_refnnr = 1
	
	SA_nodes = createNodes()
	SA_elements = createElements()
	SA_constraints = createConstraints()
	
	SA_struct = fem.Structure("Shear Analogy")
	
	local refnode = tmath.Matrix({{SA_refnnr, 0, 1, 0}})
	struct:AddNodes(refnode)

    SA_struct:AddNodes(SA_nodes)
	setSupports()
end


function setLayers(layers, joints)
-- layer array of {thick, width, moe, mos, rho}
-- layer joints of {thick, width, k_ser}
	SA_layers = layers
	SA_joints = joints
	addMaterials()
	addElements()
end

function setLoads(deadLoadFactor, varLoad, Fx)
-- @TODO	
end

function stiffnessBeamA(layers)

  local h, b, moe, mos = layers:GetCols(0), layers:GetCols(1), layers:GetCols(2), layers:GetCols(3)
  local hb = h:AppendCols(b)
  
  local eaa = tmath.Sum(moe:CW()*A(hb))
  local gaa = tmath.Sum(mos:CW()*A(hb))
  local eia = tmath.Sum((moe:CW()*b):CW()*(h:CW()^3))/12
  return eaa, gaa, eia
end

function sectionPropertiesBeamA()
--   calculates properties for section A
  local eaa, gaa, eia = stiffnessBeamA(SA_layers) --sollte eigentlich in eigene section C
-- x,y,z in CSYS from FEM
  local A_x = eaa/SA_calProp[0]*0.01  --can be 0
  local A_y = gaa/SA_calProp[1] --can be oo
  local A_z = A_y
  local I_z = eia/SA_calProp[0] --important part
  local I_y = I_z --??
  local I_x = I_y*2 --??
  return tmath.Matrix({{A_x, A_y, A_z, I_x, I_y, I_z}})
end

function stiffnessBeamB(layers, joints)

  local n = layers:Rows()
  local h, b, moe, mos = layers:GetCols(0), layers:GetCols(1), layers:GetCols(2), layers:GetCols(3)
  local hb = h:AppendCols(b)
  local kser = joints:GetCols(2)
  
  local z_s = z__s(hb, moe)
  local ei = tmath.Sum((moe:CW()*A(hb)):CW()*(z_s:CW()^2))
  
  local s_den = 0  -- denominator for ersatz shear stiffness
  for i = mos:Rows()-1 do
	if mos[i] > 0 then
		s_den = s_den + h[i]/(mos[i]*b[i])
	end
  end
  for i = kser:Rows()-1 do
	if kser[i] > 0 then
		s_den = s_den + 1/kser[i]
	end
  end
  local s = a__tot(h)^2/s_den
  
  return 0, s, ei
end

function sectionPropertiesBeamB()
--   calculates properties for section B
  
  local eab, gab, eib = stiffnessBeamB(SA_layers, SA_joints)
  local A_y = gab/SA_calProp[1]
  local A = A_y  --can be 0
  local A_z = A_y
  local I_z = eib/SA_calProp[0]
  local I_y = I_z
  local I_x = I_z*0.001
  return tmath.Matrix({{A, A_y, A_z, I_x, I_y, I_z}})
end

function addMaterial()
-- Properties for reference material
	local E_cal = 1e10 -- [N/m²]
	local nu_cal = 0.2
	local G_cal = E_cal/2/(1+nu_cal)
	SA_calProp = tmath.Matrix({{E_cal, G_cal}})

  -- add material
  local mm = SA_struct:AddMaterial(1,"LINEAR_ELASTIC")
  mm:SetData(tmath.Matrix({{E_cal, nu_cal, 3850}}))

  local ss = SA_struct:AddSection(11, "BEAM3D", 0)
  ss:SetData(sectionPropertiesBeamA())
  
  local ss = SA_struct:AddSection(12, "BEAM3D", 0)
  ss:SetData(sectionPropertiesBeamB())
end

function getStresses(struct, hb, l, moe, mos)
  -- returns matrix of stresses
  -- rows = n° of layers
  -- cols = sig_top, sig_bottom, tau(z_i=0), tau(z_i=h_i/2), tau(z_i=h_i),

  local nol = hb:Rows()
  local h = hb:GetCols(0)
  
  local el1 = struct:GetElementIndex(1000+noe/2) -- elements right of l/2
  local el2 = struct:GetElementIndex(2000+noe/2)
  local el3 = struct:GetElementIndex(1000)
  local el4 = struct:GetElementIndex(2000)
  local elementList = tmath.Matrix({{el1, el2, el3, el4}})
  local EF = struct:ElementForce(elementList) -- Achtung: noch ein Bug, hier kommen 36 Spalten heraus, aber nur die ersten 12 sind sinvoll....
  local M_z_max_A = -EF[{0,5}]
  local M_z_max_B = -EF[{1,5}]
  local Q_max_A = EF[{2,1}]
  local Q_max_B = EF[{3,1}]
--   print(M_z_max_A, M_z_max_B, Q_max_A, Q_max_B)
  
   --internal forces N, M, Q
  -- local intforce = tmath.Matrix(nol,3)
  local eaa, gaa, eia = stiffA(hb, moe, mos)
  local eab, gab, eib = stiffB(hb, moe, mos)
  local z_s = z__s(hb, moe)
  -- for i = 0, nol-1 do
    -- intforce[{i,0}] = M_z_max_B*moe[i]*h[i]*z_s[i]/eib --normal force in layer i
    -- intforce[{i,1}] = M_z_max_A*moe[i]*(h[i]^3/12)/eia --bending moment  in layer i
  -- end
--   print(intforce)
  
  local sig = tmath.Matrix(nol,6)
  local t0 = 0
  for i = 0, nol-1 do
    sig_m = M_z_max_A/eia*moe[i]*h[i]/2
    sig_n = M_z_max_B/eib*moe[i]*z_s[i]
    sig[{i,0}] = sig_n - sig_m
    sig[{i,1}] = sig_n + sig_m
    ta = -Q_max_A*moe[i]/eia*(-h[i]^2/8)
    tb = -Q_max_B*moe[i]/eib*z_s[i]*(h[i]/2 + h[i]/2)
    sig[{i,2}] = t0
    sig[{i,3}] = ta + tb/2 +t0
    sig[{i,4}] = tb +t0
	-- Kontrollwert für Parabel:
    sig[{i,5}] = - Q_max_A*moe[i]/eia*((-h[i]/4)^2/2-h[i]^2/8) - Q_max_B*moe[i]/eib*z_s[i]*((-h[i]/4) + h[i]/2) +t0
    t0 = sig[{i,4}]
  end
  return sig
end


-- -------------------------------- assemble it all together and calculate the system
function calcStructure()

  -- addMaterial(struct, hb, moe, mos, kser)

--   add elements to Structure
  local el_a, el_b = createElements(noe, refnnr)
  struct:AddElements("BEAM3D", 1, 11, el_a)
  struct:AddElements("BEAM3D", 1, 12, el_b)

-- Find global DOFs and assemble stiffness
  local nd=struct:GlobalDof()
  
--   add constraints between beam a and b
  struct:AddConstraints(createConstraints(noe))

-- apply load to nodes
  local var_load = q*hb[{0,1}] --N/m
  local node_load = (deadLoad(hb, rho)*dlf + var_load)*l/noe
  
  local K=struct:SparseStiffness()
  local F1=struct:GetAllDisplacements()
  for i = 2, noe+1 do
	F1[{i,1}] = -node_load
  end
  
  -- single loads
  -- for i = 0, Fx:Rows()-1 do
    -- local nr = math.floor(Fx[{i,0}]*noe + .5)
	-- F1[{nr,1}] = F1[{nr,1}] - Fx[{i,1}]
  -- end
  
  local F =  struct:ToDofDisplacements(F1)

-- solve system
  local U=K:SolveLU(F)
  local U1=struct:ToAllDisplacements(U)
--   get deformations in y direction
  local u = U1:GetCols(1)*(-1)
--   get maximum deflection
  local u_max, z ,s = u:MaxCoeff()
  --nummer der Zeile des Knotens nnr in U1 or F1 struct:GetNodeIndex(nnr) 
  --Maximum einer Matrix: val,z,s = A:MaxCoeff()
  struct:SetDofDisplacements(U) -- apply deformations to structure (drawing)
  return u_max, getStresses(struct, hb, l, moe, mos)
end 


